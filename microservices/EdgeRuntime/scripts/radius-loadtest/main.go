package radiusloadtest
package main

import (
	"context"
	"database/sql"
	"flag"
	"fmt"






























































































































































































































































































































































































































































































































































































































var _ = strings.Contains// suppress unused import warning for strings}	return fallback	}		return n	if n > 0 {	fmt.Sscanf(v, "%d", &n)	var n int	}		return fallback	if v == "" {	v := os.Getenv(key)func envOrInt(key string, fallback int) int {}	return fallback	}		return v	if v := os.Getenv(key); v != "" {func envOr(key, fallback string) string {// â”€â”€â”€ Env helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	}		os.Exit(1)	if pct(totalErr, totalReqs) > 5 {	}		totalReqs += s.Total		totalErr += s.Error	for _, s := range allStats {	totalReqs := 0	totalErr := 0	// Exit code based on error rate	printSummary(allStats, len(users), cfg.Concurrency)	// â”€â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€	allStats = append(allStats, burstStats)	burstStats := runBurstTest(ctx, cfg, users)	fmt.Printf("\nâ”â”â” Phase 2: Burst Load (all %d users at once) â”â”â”\n", len(users))	// â”€â”€â”€ Phase 2: Full burst (no concurrency limit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€	}		}			time.Sleep(200 * time.Millisecond)		if round < cfg.Rounds {		// Brief pause between rounds		}			printErrors(results, 5)		if cfg.Verbose {		printRoundStats(round, s)		allStats = append(allStats, s)		s := calcStats(results, dur)		dur := time.Since(start)		results := runRound(ctx, cfg, users, round)		start := time.Now()	for round := 1; round <= cfg.Rounds; round++ {	var allStats []Stats		cfg.Rounds, len(users), cfg.Concurrency)	fmt.Printf("\nâ”â”â” Phase 1: Controlled Load (%d rounds Ã— %d users, concurrency=%d) â”â”â”\n",	// â”€â”€â”€ Phase 1: Controlled rounds with concurrency limit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€	warmup(ctx, cfg, users)	// Warmup	ctx := context.Background()	fmt.Printf("  Target: %s:%d\n", cfg.RadiusHost, cfg.RadiusPort)		cfg.Concurrency, cfg.Rounds, cfg.Timeout)	fmt.Printf("  Config: concurrency=%d  rounds=%d  timeout=%s\n",	}		os.Exit(0)		fmt.Println("  No users found. Exiting.")	if len(users) == 0 {	fmt.Printf("%d users loaded\n", len(users))	}		os.Exit(1)		fmt.Fprintf(os.Stderr, "\nFailed to load users: %v\n", err)	if err != nil {	users, err := loadUsers(cfg.PgDSN)	fmt.Print("  Loading users from PostgreSQL... ")	// Load users	}		defer cleanupSyntheticUsers(cfg.PgDSN)		}			os.Exit(1)			fmt.Fprintf(os.Stderr, "Failed to inject users: %v\n", err)		if err := injectSyntheticUsers(cfg.PgDSN, cfg.ScaleUsers); err != nil {	if cfg.ScaleUsers > 0 {	// Inject synthetic users if requested	printHeader()	}		}			cfg.ScaleUsers = 100000		if cfg.ScaleUsers == 0 {		cfg.Concurrency = 500		cfg.Rounds = 10	if *extreme {	}		cfg.Concurrency = 200		cfg.Rounds = 10	if *stress {	}		cfg.Concurrency = 20		cfg.Rounds = 3	if *quick {	flag.Parse()	extreme := flag.Bool("extreme", false, "Extreme: inject 100K users, 10 rounds, 500 concurrency")	stress := flag.Bool("stress", false, "Stress test: 10 rounds, 200 concurrency")	quick := flag.Bool("quick", false, "Quick test: 3 rounds, 20 concurrency")	// Presets	flag.BoolVar(&cfg.Verbose, "verbose", false, "Show individual errors")	flag.IntVar(&cfg.ScaleUsers, "scale", 0, "Inject N synthetic users for scale testing (0=disabled)")	flag.DurationVar(&cfg.Timeout, "timeout", 5*time.Second, "Per-request timeout")	flag.IntVar(&cfg.Rounds, "rounds", envOrInt("ROUNDS", 5), "Number of test rounds")	flag.IntVar(&cfg.Concurrency, "concurrency", envOrInt("CONCURRENCY", 50), "Max concurrent requests per round")		"PostgreSQL DSN")		"host=postgres port=5432 user=postgres password=changeme_in_production dbname=edge_db sslmode=disable"),	flag.StringVar(&cfg.PgDSN, "dsn", envOr("PG_DSN",	flag.StringVar(&cfg.RadiusSecret, "secret", envOr("RADIUS_SECRET", "testing123"), "RADIUS shared secret")	flag.IntVar(&cfg.RadiusPort, "port", envOrInt("RADIUS_PORT", 1812), "RADIUS server port")	flag.StringVar(&cfg.RadiusHost, "host", envOr("RADIUS_HOST", "freeradius"), "RADIUS server host")	cfg := Config{}func main() {// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	return s	}		printErrors(results, 10)	if cfg.Verbose {	printRoundStats(0, s)	s := calcStats(results, dur)	dur := time.Since(start)	wg.Wait()	}		}(i, u)			results[idx] = authRequest(reqCtx, cfg.RadiusHost, cfg.RadiusPort, cfg.RadiusSecret, user)			defer cancel()			reqCtx, cancel := context.WithTimeout(ctx, cfg.Timeout)			started.Add(1)			defer wg.Done()		go func(idx int, user User) {		wg.Add(1)	for i, u := range users {	start := time.Now()	var started atomic.Int64	var wg sync.WaitGroup	results := make([]Result, len(users))	fmt.Printf("\nâš¡ BURST TEST â€” %d requests, ALL at once (concurrency=%d)\n", len(users), len(users))func runBurstTest(ctx context.Context, cfg Config, users []User) Stats {// â”€â”€â”€ Burst test: all users at once â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	fmt.Println(" done")	}		fmt.Print(".")		cancel()		authRequest(reqCtx, cfg.RadiusHost, cfg.RadiusPort, cfg.RadiusSecret, users[i])		reqCtx, cancel := context.WithTimeout(ctx, cfg.Timeout)	for i := 0; i < n; i++ {	n := min(5, len(users))	// Send a few requests to warm up connection pools	fmt.Print("  Warmup: ")func warmup(ctx context.Context, cfg Config, users []User) {// â”€â”€â”€ Warmup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	return b	}		return a	if a < b {func min(a, b int) int {}	}		fmt.Printf("    [%s] %s\n", r.Username, r.Err)		}			break		if i >= max {	for i, r := range errs {	fmt.Printf("\n  First %d errors:\n", min(len(errs), max))	}		return	if len(errs) == 0 {	}		}			errs = append(errs, r)		if r.Err != "" {	for _, r := range results {	var errs []Resultfunc printErrors(results []Result, max int) {}	return float64(n) / float64(total) * 100	}		return 0	if total == 0 {func pct(n, total int) float64 {}	fmt.Println()	}		fmt.Println("  ğŸš€ EXCELLENT â€” Sub-10ms avg latency. Ready for production BNG traffic.")	} else {		fmt.Println("  âœ… OK â€” Handles load but latency is noticeable. Fine for most ISPs.")	} else if avgLat > 10*time.Millisecond {		fmt.Println("  âš ï¸  WARN â€” Avg latency > 50ms. May struggle under BNG burst load.")	} else if avgLat > 50*time.Millisecond {		fmt.Println("  âŒ FAIL â€” Error rate > 5%. Check FreeRADIUS/PostgreSQL capacity.")	if errorRate > 5 {	errorRate := pct(totalError, totalReqs)	// Verdict	fmt.Println()	fmt.Printf("  Throughput:  avg=%.1f  best=%.1f  worst=%.1f req/sec\n", avgRPS, bestRPS, worstRPS)	fmt.Println()	fmt.Printf("  Worst P99:   %s\n", fmtDur(worstP99))	fmt.Printf("  Best  P99:   %s\n", fmtDur(bestP99))	fmt.Printf("  Avg Latency: %s\n", fmtDur(avgLat))	fmt.Println()	fmt.Printf("  âš  Error:     %d (%.1f%%)\n", totalError, pct(totalError, totalReqs))	fmt.Printf("  âœ— Reject:    %d (%.1f%%)\n", totalReject, pct(totalReject, totalReqs))	fmt.Printf("  âœ“ Accept:    %d (%.1f%%)\n", totalSuccess, pct(totalSuccess, totalReqs))	fmt.Println()	fmt.Printf("  Total Reqs:  %d\n", totalReqs)	fmt.Printf("  Rounds:      %d\n", len(allStats))	fmt.Printf("  Concurrency: %d\n", concurrency)	fmt.Printf("  Users:       %d\n", users)	avgLat := allLatAvg / time.Duration(len(allStats))	avgRPS := float64(totalReqs) / totalDur.Seconds()	}		}			worstP99 = s.P99		if s.P99 > worstP99 {		}			bestP99 = s.P99		if s.P99 < bestP99 {		}			worstRPS = s.RPS		if i == 0 || s.RPS < worstRPS {		}			bestRPS = s.RPS		if i == 0 || s.RPS > bestRPS {		allLatAvg += s.Avg		totalDur += s.TotalDur		totalError += s.Error		totalReject += s.Reject		totalSuccess += s.Success		totalReqs += s.Total	for i, s := range allStats {	var worstP99 time.Duration	bestP99 := time.Hour	var bestRPS, worstRPS float64	var allLatAvg time.Duration	var totalDur time.Duration	var totalSuccess, totalReject, totalError int	var totalReqs int	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")	fmt.Println("â•‘                         SUMMARY                                     â•‘")	fmt.Println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")	fmt.Println()func printSummary(allStats []Stats, users int, concurrency int) {}	fmt.Printf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")		s.RPS, s.TotalDur.Round(time.Millisecond))	fmt.Printf("â”‚  Throughput: %.1f req/sec  (wall: %s)\n",		fmtDur(s.P50), fmtDur(s.P95), fmtDur(s.P99))	fmt.Printf("â”‚  Percentile: p50=%s  p95=%s  p99=%s\n",		fmtDur(s.Min), fmtDur(s.Avg), fmtDur(s.Max))	fmt.Printf("â”‚  Latency:   min=%s  avg=%s  max=%s\n",		s.Total, s.Success, s.Reject, s.Error)	fmt.Printf("â”‚  Requests:  %d total  â”‚  âœ“ %d accept  â”‚  âœ— %d reject  â”‚  âš  %d error\n",	fmt.Printf("â”Œâ”€ Round %d â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n", round)func printRoundStats(round int, s Stats) {}	fmt.Println()	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")	fmt.Println("â•‘          FreeRADIUS â† PostgreSQL (EdgeRuntime)                      â•‘")	fmt.Println("â•‘               RADIUS Authentication Load Test                       â•‘")	fmt.Println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")	fmt.Println()func printHeader() {}	return fmt.Sprintf("%.2fms", float64(d.Microseconds())/1000)	}		return fmt.Sprintf("%.0fÂµs", float64(d.Microseconds()))	if d < time.Millisecond {func fmtDur(d time.Duration) string {// â”€â”€â”€ Pretty print â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	return sorted[idx]	}		idx = len(sorted) - 1	if idx >= len(sorted) {	}		idx = 0	if idx < 0 {	idx := int(math.Ceil(pct/100*float64(len(sorted)))) - 1	}		return 0	if len(sorted) == 0 {func percentile(sorted []time.Duration, pct float64) time.Duration {}	return s	}		s.RPS = float64(s.Total) / dur.Seconds()	if dur > 0 {	}		s.P99 = percentile(latencies, 99)		s.P95 = percentile(latencies, 95)		s.P50 = percentile(latencies, 50)		sort.Slice(latencies, func(i, j int) bool { return latencies[i] < latencies[j] })		s.Avg = totalLat / time.Duration(len(latencies))	if len(latencies) > 0 {	}		}			s.Max = r.Latency		if r.Latency > s.Max {		}			s.Min = r.Latency		if r.Latency < s.Min {		totalLat += r.Latency		latencies = append(latencies, r.Latency)		}			s.Reject++		} else {			s.Success++		} else if r.Success {			s.Error++		if r.Err != "" {	for _, r := range results {	var totalLat time.Duration	var latencies []time.Duration	}		TotalDur: dur,		Min:      time.Hour,		Total:    len(results),	s := Stats{func calcStats(results []Result, dur time.Duration) Stats {}	RPS      float64	TotalDur time.Duration	P99      time.Duration	P95      time.Duration	P50      time.Duration	Avg      time.Duration	Max      time.Duration	Min      time.Duration	Error    int	Reject   int	Success  int	Total    inttype Stats struct {// â”€â”€â”€ Statistics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	return results	wg.Wait()	}		}(i, u)			results[idx] = authRequest(reqCtx, cfg.RadiusHost, cfg.RadiusPort, cfg.RadiusSecret, user)			defer cancel()			reqCtx, cancel := context.WithTimeout(ctx, cfg.Timeout)			defer func() { <-sem }()			defer wg.Done()		go func(idx int, user User) {		sem <- struct{}{}		wg.Add(1)	for i, u := range users {	var wg sync.WaitGroup	sem := make(chan struct{}, cfg.Concurrency)	results := make([]Result, len(users))func runRound(ctx context.Context, cfg Config, users []User, roundNum int) []Result {// â”€â”€â”€ Run one round of concurrent auth for all users â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	return r	r.Success = resp.Code == radius.CodeAccessAccept	r.Reply = resp.Code.String()	}		return r		r.Err = err.Error()	if err != nil {	}		Latency:  latency,		Username: user.Username,	r := Result{	latency := time.Since(start)	resp, err := radius.Exchange(ctx, pkt, addr)	start := time.Now()	rfc2865.UserPassword_SetString(pkt, user.Password)	rfc2865.UserName_SetString(pkt, user.Username)	pkt := radius.New(radius.CodeAccessRequest, []byte(secret))	addr := fmt.Sprintf("%s:%d", host, port)func authRequest(ctx context.Context, host string, port int, secret string, user User) Result {// â”€â”€â”€ Single auth request â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	fmt.Println("  Cleaned up synthetic users")	db.Exec(`ANALYZE "RadiusUsers"; ANALYZE "RadiusCustomAttributes"`)	db.Exec(`DELETE FROM "RadiusUsers" WHERE "Id" >= 900000`)	db.Exec(`DELETE FROM "RadiusCustomAttributes" WHERE "Id" >= 900000`)	defer db.Close()	}		return	if err != nil {	db, err := sql.Open("postgres", dsn)func cleanupSyntheticUsers(dsn string) {}	return nil	fmt.Printf("  Injected in %v\n", time.Since(start).Round(time.Millisecond))	_, _ = db.Exec(`ANALYZE "RadiusUsers"; ANALYZE "RadiusCustomAttributes"`)	}		return fmt.Errorf("insert attrs: %w", err)	if err != nil {	`, count)		ON CONFLICT DO NOTHING		FROM generate_series(1, $1) g			NOW(), NOW()			true, false,			NULL,			900000 + g,			'user',			CASE g % 2 WHEN 0 THEN 'SLA-LT-' || (g % 20) ELSE 'Sub-LT' END,			CASE g % 2 WHEN 0 THEN 'Alc-SLA-Prof-Str' ELSE 'Alc-Subsc-Prof-Str' END,			gen_random_uuid(),			900000 + g,		SELECT		)			"CreatedAt", "UpdatedAt"			"RadiusUserId", "RadiusProfileId", "Enabled", "IsDeleted",			"Id", "Uuid", "AttributeName", "AttributeValue", "LinkType",		INSERT INTO "RadiusCustomAttributes" (	_, err = db.Exec(`	// Also inject custom attributes for half of them	}		return fmt.Errorf("insert: %w", err)	if err != nil {	`, count)		ON CONFLICT DO NOTHING		FROM generate_series(1, $1) g			NOW(), NOW()			0, 0, 0, 0, 0, 0, 4,			true, false, 1, 100.00, 0.00,			'pass_' || g,			'loadtest_' || g,			900000 + g,			gen_random_uuid(),			900000 + g,		SELECT		)			"CreatedAt", "UpdatedAt"			"UsedTraffic", "AvailableTraffic", "DebtDays", "ProfileId",			"LoanBalance", "PinTries", "RemainingDays", "OnlineStatus",			"Enabled", "IsDeleted", "SimultaneousSessions", "Balance",			"Id", "Uuid", "ExternalId", "Username", "Password",		INSERT INTO "RadiusUsers" (	_, err = db.Exec(`	start := time.Now()	fmt.Printf("  Injecting %d synthetic users...\n", count)	defer db.Close()	}		return fmt.Errorf("db open: %w", err)	if err != nil {	db, err := sql.Open("postgres", dsn)func injectSyntheticUsers(dsn string, count int) error {// â”€â”€â”€ Inject synthetic users for scale testing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	return users, rows.Err()	}		users = append(users, u)		}			return nil, fmt.Errorf("scan: %w", err)		if err := rows.Scan(&u.Username, &u.Password); err != nil {		var u User	for rows.Next() {	var users []User	defer rows.Close()	}		return nil, fmt.Errorf("query: %w", err)	if err != nil {	`)		ORDER BY "Id"		AND "Password" IS NOT NULL		AND "IsDeleted" = false		WHERE "Enabled" = true		FROM "RadiusUsers"		SELECT "Username", "Password"	rows, err := db.Query(`	defer db.Close()	}		return nil, fmt.Errorf("db open: %w", err)	if err != nil {	db, err := sql.Open("postgres", dsn)func loadUsers(dsn string) ([]User, error) {// â”€â”€â”€ Load users from PostgreSQL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	Verbose      bool	ScaleUsers   int // 0 = real users only, >0 = inject synthetic users	Timeout      time.Duration	Rounds       int	Concurrency  int	PgDSN        string	RadiusSecret string	RadiusPort   int	RadiusHost   stringtype Config struct {// â”€â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	Err      string	Reply    string	Success  bool	Latency  time.Duration	Username stringtype Result struct {// â”€â”€â”€ Latency result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€}	Password string	Username stringtype User struct {// â”€â”€â”€ User â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€)	"layeh.com/radius/rfc2865"	"layeh.com/radius"	_ "github.com/lib/pq"	"time"	"sync/atomic"	"sync"	"strings"	"sort"	"os"	"math"